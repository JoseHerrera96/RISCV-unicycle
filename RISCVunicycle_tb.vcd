$date
	Sun Mar 16 01:44:05 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ns
$end
$scope module RISCVunicycle_tb $end
$var parameter 32 ! CLK_PERIOD $end
$var reg 1 " clock $end
$var reg 1 # rst $end
$scope module dut $end
$var wire 1 " clock $end
$var wire 1 # rst $end
$var wire 1 $ zero $end
$var wire 32 % pc_out [31:0] $end
$var wire 32 & instruct [31:0] $end
$var wire 32 ' ext_imm [31:0] $end
$var wire 32 ( dout [31:0] $end
$var wire 32 ) D2 [31:0] $end
$var wire 32 * D1 [31:0] $end
$var wire 32 + ALUout [31:0] $end
$var reg 32 , Aluin1 [31:0] $end
$var reg 32 - Aluin2 [31:0] $end
$var reg 5 . R1 [4:0] $end
$var reg 5 / R2 [4:0] $end
$var reg 5 0 Rd [4:0] $end
$var reg 32 1 addrs [31:0] $end
$var reg 4 2 alu_op [3:0] $end
$var reg 32 3 alu_src [31:0] $end
$var reg 32 4 datainmemory [31:0] $end
$var reg 32 5 dataregin [31:0] $end
$var reg 4 6 funct3 [3:0] $end
$var reg 7 7 funct7 [6:0] $end
$var reg 12 8 imm [11:0] $end
$var reg 32 9 instaddr [31:0] $end
$var reg 1 : mem_read $end
$var reg 1 ; mem_write $end
$var reg 7 < opcode [6:0] $end
$var reg 32 = outp [31:0] $end
$var reg 1 > pcnext $end
$var reg 1 ? regenb $end
$scope module extensorS $end
$var wire 7 @ typ [6:0] $end
$var wire 32 A instruct [31:0] $end
$var wire 12 B inS [11:0] $end
$var wire 12 C inL [11:0] $end
$var wire 12 D in [11:0] $end
$var reg 32 E out [31:0] $end
$upscope $end
$scope module modInstm $end
$var wire 1 F RegWrite $end
$var wire 32 G WriteData [31:0] $end
$var wire 32 H WriteReg [31:0] $end
$var wire 32 I addr [31:0] $end
$var wire 1 J clock $end
$var wire 32 K instruct [31:0] $end
$upscope $end
$scope module modPC $end
$var wire 1 " clk $end
$var wire 1 > pcnext $end
$var wire 1 # reset $end
$var reg 32 L pc_reg [31:0] $end
$upscope $end
$scope module modalu $end
$var wire 32 M A [31:0] $end
$var wire 4 N ALUctl [3:0] $end
$var wire 32 O B [31:0] $end
$var reg 32 P ALUout [31:0] $end
$var reg 1 $ zero $end
$upscope $end
$scope module modmemory $end
$var wire 32 Q address [31:0] $end
$var wire 1 " clk $end
$var wire 1 : read_enable $end
$var wire 32 R write_data [31:0] $end
$var wire 1 ; write_enable $end
$var reg 32 S read_data [31:0] $end
$upscope $end
$scope module modregfile $end
$var wire 32 T Data1 [31:0] $end
$var wire 32 U Data2 [31:0] $end
$var wire 5 V RD [4:0] $end
$var wire 5 W Read1 [4:0] $end
$var wire 5 X Read2 [4:0] $end
$var wire 1 ? RegWrite $end
$var wire 32 Y WriteData [31:0] $end
$var wire 1 " clock $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
b10 !
$end
#0
$dumpvars
bx Y
b0 X
b0 W
b110 V
bx U
bx T
bx S
bx R
bx Q
bx P
bx O
b0 N
bx M
b0 L
b10001100000011 K
zJ
b0 I
bz H
bz G
zF
b110 E
b0 D
b110 C
b11 B
b10001100000011 A
b11 @
1?
x>
bx =
b11 <
x;
0:
b0 9
bx 8
bx 7
b10 6
bx 5
bx 4
bx 3
b0 2
bx 1
b110 0
b0 /
b0 .
bx -
bx ,
bx +
bx *
bx )
bx (
b110 '
b10001100000011 &
b0 %
x$
0#
0"
$end
#2000000
b111 '
b111 E
b0xx0 5
b0xx0 Y
b0xx0 =
b0xx0 +
b0xx0 P
b100 D
b10000000011 B
b111 C
b110 -
b110 O
b110 3
1?
b111 0
b111 V
b10 )
b10 U
b100 /
b100 X
b10000000010001110000011 &
b10000000010001110000011 A
b10000000010001110000011 K
b1 9
b1 I
b1 %
b1 L
1"
#3000000
0"
#4000000
b11100 '
b11100 E
b0xxx 5
b0xxx Y
b0xxx =
b0xxx +
b0xxx P
b1000 D
b1110 B
b11100 C
b111 -
b111 O
b111 3
1?
b11100 0
b11100 V
bx )
bx U
b1000 /
b1000 X
b100000000010111000000011 &
b100000000010111000000011 A
b100000000010111000000011 K
b10 9
b10 I
b10 %
b10 L
1"
#5000000
0"
#6000000
b11101 '
b11101 E
b0xxx00 5
b0xxx00 Y
b0xxx00 =
b0xxx00 +
b0xxx00 P
b1100 D
b10000001110 B
b11101 C
b11100 -
b11100 O
b11100 3
1?
b11101 0
b11101 V
b1100 /
b1100 X
b110000000010111010000011 &
b110000000010111010000011 A
b110000000010111010000011 K
b11 9
b11 I
b11 %
b11 L
1"
#7000000
