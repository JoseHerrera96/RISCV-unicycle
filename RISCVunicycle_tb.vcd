$date
	Thu Aug 08 21:55:11 2024
$end
$version
	Icarus Verilog
$end
$timescale
	1ns
$end
$scope module RISCVunicycle_tb $end
$var parameter 32 ! CLK_PERIOD $end
$var reg 1 " clock $end
$var reg 1 # rst $end
$scope module dut $end
$var wire 1 " clock $end
$var wire 1 # rst $end
$var wire 1 $ zero $end
$var wire 32 % pc_out [31:0] $end
$var wire 32 & instruct [31:0] $end
$var wire 32 ' ext_imm [31:0] $end
$var wire 32 ( dout [31:0] $end
$var wire 32 ) D2 [31:0] $end
$var wire 32 * D1 [31:0] $end
$var wire 32 + ALUout [31:0] $end
$var reg 32 , Aluin1 [31:0] $end
$var reg 32 - Aluin2 [31:0] $end
$var reg 5 . R1 [4:0] $end
$var reg 5 / R2 [4:0] $end
$var reg 5 0 Rd [4:0] $end
$var reg 32 1 addrs [31:0] $end
$var reg 4 2 alu_op [3:0] $end
$var reg 32 3 alu_src [31:0] $end
$var reg 32 4 datainmemory [31:0] $end
$var reg 32 5 dataregin [31:0] $end
$var reg 4 6 funct3 [3:0] $end
$var reg 7 7 funct7 [6:0] $end
$var reg 12 8 imm [11:0] $end
$var reg 32 9 instaddr [31:0] $end
$var reg 1 : mem_read $end
$var reg 1 ; mem_write $end
$var reg 7 < opcode [6:0] $end
$var reg 32 = outp [31:0] $end
$var reg 1 > pcnext $end
$var reg 1 ? regenb $end
$scope module extensorS $end
$var wire 7 @ typ [6:0] $end
$var wire 32 A instruct [31:0] $end
$var wire 12 B inS [11:0] $end
$var wire 12 C inL [11:0] $end
$var wire 12 D in [11:0] $end
$var reg 32 E out [31:0] $end
$upscope $end
$scope module modInstm $end
$var wire 1 F RegWrite $end
$var wire 32 G WriteData [31:0] $end
$var wire 32 H WriteReg [31:0] $end
$var wire 32 I addr [31:0] $end
$var wire 1 J clock $end
$var wire 32 K instruct [31:0] $end
$upscope $end
$scope module modPC $end
$var wire 1 " clk $end
$var wire 1 > pcnext $end
$var wire 1 # reset $end
$var reg 32 L pc_reg [31:0] $end
$upscope $end
$scope module modalu $end
$var wire 32 M A [31:0] $end
$var wire 4 N ALUctl [3:0] $end
$var wire 32 O B [31:0] $end
$var reg 32 P ALUout [31:0] $end
$var reg 1 $ zero $end
$upscope $end
$scope module modmemory $end
$var wire 32 Q address [31:0] $end
$var wire 1 " clk $end
$var wire 1 : read_enable $end
$var wire 32 R write_data [31:0] $end
$var wire 1 ; write_enable $end
$var reg 32 S read_data [31:0] $end
$upscope $end
$scope module modregfile $end
$var wire 32 T Data1 [31:0] $end
$var wire 32 U Data2 [31:0] $end
$var wire 5 V RD [4:0] $end
$var wire 5 W Read1 [4:0] $end
$var wire 5 X Read2 [4:0] $end
$var wire 1 ? RegWrite $end
$var wire 32 Y WriteData [31:0] $end
$var wire 1 " clock $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
b10 !
$end
#0
$dumpvars
b0 Y
b0 X
b0 W
b0 V
bx U
bx T
bx S
b0 R
b0 Q
b0 P
b0 O
b0 N
bx M
b0 L
b0 K
zJ
b0 I
bz H
bz G
zF
bx E
b0 D
b0 C
b0 B
b0 A
b0 @
0?
0>
b0 =
b0 <
0;
0:
b0 9
b0 8
bx 7
b0 6
b0 5
b0 4
b0 3
b0 2
b0 1
b0 0
b0 /
b0 .
b0 -
bx ,
b0 +
bx *
bx )
bx (
bx '
b0 &
b0 %
x$
1#
0"
$end
#1000000
0#
#3000000
b11 5
b11 Y
b11 =
b11 +
b11 P
b1010 D
b10000000000 B
b1 C
b1 -
b1 O
b10 ,
b10 M
b1 3
1?
b10 2
b10 N
b0 7
b1 0
b1 V
b1 )
b1 U
b1010 /
b1010 X
b10 *
b10 T
b100 .
b100 W
b110011 <
b110011 @
b101000100000000010110011 &
b101000100000000010110011 A
b101000100000000010110011 K
b1 9
b1 I
b1 %
b1 L
1"
#4000000
0"
#5000000
b10 5
b10 Y
b10 =
b10 +
b10 P
b10000000011 D
b11000000000 B
b10000000001 C
b10 -
b10 O
b100 ,
b100 M
b10 3
b100000 7
b110 2
b110 N
1?
b10 )
b10 U
b11 /
b11 X
b100 *
b100 T
b10 .
b10 W
b1000000001100010000000010110011 &
b1000000001100010000000010110011 A
b1000000001100010000000010110011 K
b10 9
b10 I
b10 %
b10 L
1"
#6000000
0"
#7000000
b111 5
b111 Y
b111 =
b111 +
b111 P
b110 D
b10000000000 B
b1 C
b101 -
b101 O
b10 ,
b10 M
b101 3
b1 2
b1 N
b0 7
1?
b101 )
b101 U
b110 /
b110 X
b10 *
b10 T
b101 .
b101 W
b110 6
b11000101110000010110011 &
b11000101110000010110011 A
b11000101110000010110011 K
b11 9
b11 I
b11 %
b11 L
1"
#8000000
