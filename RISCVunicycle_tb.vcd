$date
	Fri Apr 25 21:04:35 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ns
$end
$scope module RISCVunicycle_tb $end
$var wire 1 ! finish_flag $end
$var parameter 32 " CLK_PERIOD $end
$var reg 1 # clock $end
$var reg 1 $ rst $end
$scope module dut $end
$var wire 1 # clock $end
$var wire 1 $ rst $end
$var wire 1 % zero $end
$var wire 32 & pc_out [31:0] $end
$var wire 1 ' last_instr_flag $end
$var wire 32 ( instruct [31:0] $end
$var wire 32 ) ext_imm [31:0] $end
$var wire 32 * dout [31:0] $end
$var wire 32 + D2 [31:0] $end
$var wire 32 , D1 [31:0] $end
$var wire 32 - ALUout [31:0] $end
$var reg 32 . Aluin1 [31:0] $end
$var reg 32 / Aluin2 [31:0] $end
$var reg 5 0 R1 [4:0] $end
$var reg 5 1 R2 [4:0] $end
$var reg 5 2 Rd [4:0] $end
$var reg 32 3 addrs [31:0] $end
$var reg 1 4 aluSrc_cntrl_ready $end
$var reg 4 5 alu_op [3:0] $end
$var reg 1 6 alu_ready $end
$var reg 32 7 alu_src [31:0] $end
$var reg 1 8 branch $end
$var reg 32 9 branch_offset [31:0] $end
$var reg 1 : busy $end
$var reg 32 ; datainmemory [31:0] $end
$var reg 32 < dataregin [31:0] $end
$var reg 1 = decode_begin $end
$var reg 1 > decode_done $end
$var reg 1 ! finish_flag $end
$var reg 4 ? funct3 [3:0] $end
$var reg 7 @ funct7 [6:0] $end
$var reg 12 A imm [11:0] $end
$var reg 32 B instaddr [31:0] $end
$var reg 1 C lw_data_ready $end
$var reg 1 D mem_read $end
$var reg 1 E mem_write $end
$var reg 7 F opcode [6:0] $end
$var reg 1 G regenb $end
$scope module extensorS $end
$var wire 32 H instruct [31:0] $end
$var reg 32 I out [31:0] $end
$var reg 7 J typ [6:0] $end
$upscope $end
$scope module modInstm $end
$var wire 32 K addr [31:0] $end
$var reg 32 L d [31:0] $end
$var reg 32 M full_RF_temp [31:0] $end
$var reg 32 N instruct [31:0] $end
$var reg 32 O instruct_temp [31:0] $end
$var reg 1 ' last_instr_flag $end
$scope begin $ivl_for_loop0 $end
$var integer 32 P i [31:0] $end
$upscope $end
$scope begin $ivl_for_loop1 $end
$var integer 32 Q j [31:0] $end
$upscope $end
$scope begin $ivl_for_loop2 $end
$var integer 32 R i [31:0] $end
$upscope $end
$upscope $end
$scope module modPC $end
$var wire 1 8 branch $end
$var wire 32 S branch_offset [31:0] $end
$var wire 1 # clk $end
$var wire 1 ! finish_flag $end
$var wire 1 $ reset $end
$var reg 32 T pc_reg [31:0] $end
$var reg 32 U pc_reg_next [31:0] $end
$upscope $end
$scope module modalu $end
$var wire 32 V A [31:0] $end
$var wire 4 W ALUctl [3:0] $end
$var wire 32 X B [31:0] $end
$var reg 32 Y ALUout [31:0] $end
$var reg 1 % zero $end
$upscope $end
$scope module modmemory $end
$var wire 32 Z address [31:0] $end
$var wire 1 # clk $end
$var wire 1 D read_enable $end
$var wire 32 [ write_data [31:0] $end
$var wire 1 E write_enable $end
$var reg 32 \ read_data [31:0] $end
$upscope $end
$scope module modregfile $end
$var wire 32 ] Data1 [31:0] $end
$var wire 32 ^ Data2 [31:0] $end
$var wire 5 _ RD [4:0] $end
$var wire 5 ` Read1 [4:0] $end
$var wire 5 a Read2 [4:0] $end
$var wire 1 G RegWrite $end
$var wire 32 b WriteData [31:0] $end
$var wire 1 # clock $end
$var wire 1 ! finish_flag $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
b1111101000 "
$end
#0
$dumpvars
bx b
b0 a
b0 `
b0 _
b0 ^
b0 ]
bx \
b0 [
b0 Z
b0 Y
b0 X
b0 W
b0 V
b100 U
b0 T
b0 S
b100000 R
b100000 Q
b10000000 P
b11111111111111111111111111111111 O
b11100000000000010010011 N
bx M
b10000000 L
b0 K
b10011 J
b111 I
b11100000000000010010011 H
0G
b0 F
0E
0D
0C
b0 B
b0 A
bx @
b0 ?
0>
0=
bx <
b0 ;
0:
b0 9
08
b0 7
06
b0 5
04
b0 3
b0 2
b0 1
b0 0
b0 /
b0 .
b0 -
b0 ,
b0 +
bx *
b111 )
b11100000000000010010011 (
0'
b0 &
0%
1$
0#
0!
$end
#500000
1#
#1000000
0#
0$
#1500000
b111 <
b111 b
b111 -
b111 Y
06
b111 /
b111 X
04
b111 7
1G
0>
b10 5
b10 W
b111 A
b1 2
b1 _
b10011 F
b100 B
b100 K
0:
0=
b100 &
b100 T
1#
#2000000
0#
#2500000
06
b11111111111111111111111111110110 )
b11111111111111111111111111110110 I
04
b11111111011000000000000100010011 (
b11111111011000000000000100010011 H
b11111111011000000000000100010011 N
0>
b1000 B
b1000 K
0:
1G
0=
b1000 &
b1000 T
1#
#3000000
0#
#3500000
b11111111111111111111111111110110 <
b11111111111111111111111111110110 b
b11111111111111111111111111110110 -
b11111111111111111111111111110110 Y
06
b11111111111111111111111111110110 /
b11111111111111111111111111110110 X
b1 )
b1 I
b11 J
04
b11111111111111111111111111110110 7
b100000010001000000011 (
b100000010001000000011 H
b100000010001000000011 N
0>
b111111110110 A
b10 2
b10 _
b1100 B
b1100 K
0:
1G
0=
b1100 &
b1100 T
1#
#4000000
0#
#4500000
b1 3
b1 Z
1C
b1 -
b1 Y
06
b1 /
b1 X
b11 )
b11 I
04
b1 7
1D
b1100000010001010000011 (
b1100000010001010000011 H
b1100000010001010000011 N
0>
b1 A
b100 2
b100 _
b11 F
b10000 B
b10000 K
0:
1G
0=
b10000 &
b10000 T
1#
#5000000
0#
#5500000
b11 3
b11 Z
b11 -
b11 Y
06
b11 /
b11 X
b0 )
b0 I
b10011 J
04
b11 7
b10011 (
b10011 H
b10011 N
0>
b11 A
b101 2
b101 _
b10100 B
b10100 K
0:
1D
1G
0=
b110 <
b110 b
1C
b10100 &
b10100 T
b110 *
b110 \
1#
#6000000
0#
#6500000
b0 -
b0 Y
06
b0 /
b0 X
b110011 J
04
b0 7
b10100100000001100110011 (
b10100100000001100110011 H
b10100100000001100110011 N
0>
b0 A
b0 2
b0 _
b10011 F
b11000 B
b11000 K
0:
0D
1G
0=
b0 <
b0 b
0C
b11000 &
b11000 T
b1 *
b1 \
1#
#7000000
0#
#7500000
b111 <
b111 b
b111 -
b111 Y
06
b1 /
b1 X
b110 .
b110 V
b1000 )
b1000 I
b100011 J
04
b1 7
b11000000010010000100011 (
b11000000010010000100011 H
b11000000010010000100011 N
0>
b0 @
b110 2
b110 _
b1 +
b1 ^
b101 1
b101 a
b110 ,
b110 ]
b100 0
b100 `
b110011 F
b11100 B
b11100 K
0:
1G
0=
b11100 &
b11100 T
1#
#8000000
0#
#8500000
b1 ;
b1 [
b1000 3
b1000 Z
b1000 -
b1000 Y
06
b1000 /
b1000 X
b0 .
b0 V
b11111111111111111111111111111110 )
b11111111111111111111111111111110 I
b1100011 J
04
b1000 7
1E
b11111110011000110001111011100011 (
b11111110011000110001111011100011 H
b11111110011000110001111011100011 N
0>
b1000 A
b0 ,
b0 ]
b0 0
b0 `
b100011 F
b100000 B
b100000 K
0:
0G
0=
b100000 &
b100000 T
1#
#9000000
0#
#9500000
1G
b1000 2
b1000 _
08
b1010 <
b1010 b
1%
b1010 -
b1010 Y
06
b1010 /
b1010 X
b0 .
b0 V
b101110 )
b101110 I
b1100011 J
04
b1010 7
b100000100111111111001100011 (
b100000100111111111001100011 H
b100000100111111111001100011 N
0>
b11111111111111111111111111111110 9
b11111111111111111111111111111110 S
b1010 A
b0 ?
b0 +
b0 ^
b110 1
b110 a
b10 5
b10 W
b0 ,
b0 ]
b0 0
b0 `
b10011 F
b100010 B
b100010 K
0:
0E
0=
b100010 &
b100010 T
1#
#10000000
0#
#10500000
1!
1'
08
b11111111111111111111111111111001 <
b11111111111111111111111111111001 b
b11111111111111111111111111111001 -
b11111111111111111111111111111001 Y
06
b111 /
b111 X
b0 )
b0 I
b1111111 J
04
b111 7
b11111111111111111111111111111111 (
b11111111111111111111111111111111 H
b11111111111111111111111111111111 N
0>
b101110 9
b101110 S
b101110 A
b111 ?
b111 +
b111 ^
b1 1
b1 a
b110 5
b110 W
b11110 0
b11110 `
b100000 F
b1010100 B
b1010100 K
0:
0G
0=
b1010100 &
b1010100 T
1#
