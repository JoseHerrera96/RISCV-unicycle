$date
	Thu Apr 17 13:37:28 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ns
$end
$scope module RISCVunicycle_tb $end
$var parameter 32 ! CLK_PERIOD $end
$var reg 1 " clock $end
$var reg 1 # rst $end
$scope module dut $end
$var wire 1 " clock $end
$var wire 1 # rst $end
$var wire 1 $ zero $end
$var wire 32 % pc_out [31:0] $end
$var wire 32 & instruct [31:0] $end
$var wire 32 ' ext_imm [31:0] $end
$var wire 32 ( dout [31:0] $end
$var wire 32 ) D2 [31:0] $end
$var wire 32 * D1 [31:0] $end
$var wire 32 + ALUout [31:0] $end
$var reg 32 , Aluin1 [31:0] $end
$var reg 32 - Aluin2 [31:0] $end
$var reg 5 . R1 [4:0] $end
$var reg 5 / R2 [4:0] $end
$var reg 5 0 Rd [4:0] $end
$var reg 32 1 addrs [31:0] $end
$var reg 4 2 alu_op [3:0] $end
$var reg 32 3 alu_src [31:0] $end
$var reg 1 4 busy $end
$var reg 32 5 datainmemory [31:0] $end
$var reg 32 6 dataregin [31:0] $end
$var reg 4 7 funct3 [3:0] $end
$var reg 7 8 funct7 [6:0] $end
$var reg 12 9 imm [11:0] $end
$var reg 32 : instaddr [31:0] $end
$var reg 1 ; mem_read $end
$var reg 1 < mem_write $end
$var reg 7 = opcode [6:0] $end
$var reg 32 > outp [31:0] $end
$var reg 1 ? pcnext $end
$var reg 1 @ regenb $end
$scope module extensorS $end
$var wire 7 A typ [6:0] $end
$var wire 32 B instruct [31:0] $end
$var wire 12 C inS [11:0] $end
$var wire 12 D inL [11:0] $end
$var wire 12 E in [11:0] $end
$var reg 32 F out [31:0] $end
$upscope $end
$scope module modInstm $end
$var wire 1 G RegWrite $end
$var wire 32 H WriteData [31:0] $end
$var wire 32 I WriteReg [31:0] $end
$var wire 32 J addr [31:0] $end
$var wire 1 K clock $end
$var wire 32 L instruct [31:0] $end
$upscope $end
$scope module modPC $end
$var wire 1 " clk $end
$var wire 1 ? pcnext $end
$var wire 1 # reset $end
$var reg 32 M pc_reg [31:0] $end
$upscope $end
$scope module modalu $end
$var wire 32 N A [31:0] $end
$var wire 4 O ALUctl [3:0] $end
$var wire 32 P B [31:0] $end
$var reg 32 Q ALUout [31:0] $end
$var reg 1 $ zero $end
$upscope $end
$scope module modmemory $end
$var wire 32 R address [31:0] $end
$var wire 1 " clk $end
$var wire 1 ; read_enable $end
$var wire 32 S write_data [31:0] $end
$var wire 1 < write_enable $end
$var reg 32 T read_data [31:0] $end
$upscope $end
$scope module modregfile $end
$var wire 32 U Data1 [31:0] $end
$var wire 32 V Data2 [31:0] $end
$var wire 5 W RD [4:0] $end
$var wire 5 X Read1 [4:0] $end
$var wire 5 Y Read2 [4:0] $end
$var wire 1 @ RegWrite $end
$var wire 32 Z WriteData [31:0] $end
$var wire 1 " clock $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
b10 !
$end
#0
$dumpvars
b0 Z
b0 Y
b0 X
b0 W
bx V
bx U
bx T
b0 S
b0 R
b0 Q
b0 P
b0 O
bx N
b11111111111111111111111111111111 M
b101000100000000010110011 L
zK
b0 J
bz I
bz H
zG
bx F
b1010 E
b1 D
b10000000000 C
b101000100000000010110011 B
b0 A
0@
x?
b0 >
b0 =
0<
0;
b0 :
b0 9
bx 8
b0 7
b0 6
b0 5
04
b0 3
b0 2
b0 1
b0 0
b0 /
b0 .
b0 -
bx ,
b0 +
bx *
bx )
bx (
bx '
b101000100000000010110011 &
b11111111111111111111111111111111 %
x$
1#
0"
$end
#1000000
b11 6
b11 Z
b11 >
b11 +
b11 Q
b1 -
b1 P
b10 ,
b10 N
b1 3
1@
b10 2
b10 O
b0 8
b1 0
b1 W
b1 )
b1 V
b1010 /
b1010 Y
b10 *
b10 U
b100 .
b100 X
b110011 =
b110011 A
04
b0 %
b0 M
1"
0#
#2000000
0"
#3000000
b10 6
b10 Z
b10 >
b10 +
b10 Q
b10000000011 E
b11000000000 C
b10000000001 D
b10 -
b10 P
b100 ,
b100 N
b10 3
b100000 8
b110 2
b110 O
1@
b10 )
b10 V
b11 /
b11 Y
b100 *
b100 U
b10 .
b10 X
b1000000001100010000000010110011 &
b1000000001100010000000010110011 B
b1000000001100010000000010110011 L
b1 :
b1 J
04
b1 %
b1 M
1"
#4000000
0"
#5000000
b111 6
b111 Z
b111 >
b111 +
b111 Q
b110 E
b10000000000 C
b1 D
b101 -
b101 P
b10 ,
b10 N
b101 3
b1 2
b1 O
b0 8
1@
b101 )
b101 V
b110 /
b110 Y
b10 *
b10 U
b101 .
b101 X
b110 7
b11000101110000010110011 &
b11000101110000010110011 B
b11000101110000010110011 L
b10 :
b10 J
04
b10 %
b10 M
1"
#6000000
