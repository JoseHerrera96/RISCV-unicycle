$date
	Tue May 14 23:13:59 2024
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module RISCVunicycle_tb $end
$scope module dut $end
$var wire 1 ! clk $end
$var wire 1 " reset $end
$var wire 1 # zero $end
$var wire 32 $ pc_out [31:0] $end
$var wire 32 % instruct [31:0] $end
$var wire 32 & ext_imm [31:0] $end
$var wire 32 ' dout [31:0] $end
$var wire 32 ( D2 [31:0] $end
$var wire 32 ) D1 [31:0] $end
$var wire 32 * ALUout [31:0] $end
$var reg 32 + Aluin1 [31:0] $end
$var reg 32 , Aluin2 [31:0] $end
$var reg 5 - R1 [4:0] $end
$var reg 5 . R2 [4:0] $end
$var reg 5 / Rd [4:0] $end
$var reg 32 0 addrs [31:0] $end
$var reg 4 1 alu_op [3:0] $end
$var reg 32 2 alu_src [31:0] $end
$var reg 32 3 datainmemory [31:0] $end
$var reg 32 4 dataregin [31:0] $end
$var reg 7 5 funct3 [6:0] $end
$var reg 12 6 imm [11:0] $end
$var reg 32 7 instaddr [31:0] $end
$var reg 1 8 mem_read $end
$var reg 1 9 mem_write $end
$var reg 7 : opcode [6:0] $end
$var reg 32 ; outp [31:0] $end
$var reg 1 < regenb $end
$scope module extensorS $end
$var wire 7 = typ [6:0] $end
$var wire 32 > instruct [31:0] $end
$var wire 12 ? inS [11:0] $end
$var wire 12 @ inL [11:0] $end
$var wire 12 A in [11:0] $end
$var reg 32 B out [31:0] $end
$upscope $end
$scope module modInstm $end
$var wire 1 C RegWrite $end
$var wire 32 D WriteData [31:0] $end
$var wire 32 E WriteReg [31:0] $end
$var wire 32 F addr [31:0] $end
$var wire 1 G clock $end
$var wire 32 H instruct [31:0] $end
$upscope $end
$scope module modPC $end
$var wire 1 ! clk $end
$var wire 1 " reset $end
$var reg 32 I pc_reg [31:0] $end
$upscope $end
$scope module modalu $end
$var wire 32 J A [31:0] $end
$var wire 4 K ALUctl [3:0] $end
$var wire 32 L B [31:0] $end
$var reg 32 M ALUout [31:0] $end
$var reg 1 # zero $end
$upscope $end
$scope module modmemory $end
$var wire 32 N address [31:0] $end
$var wire 1 ! clk $end
$var wire 1 8 read_enable $end
$var wire 32 O write_data [31:0] $end
$var wire 1 9 write_enable $end
$var reg 32 P read_data [31:0] $end
$upscope $end
$scope module modregfile $end
$var wire 5 Q RD [4:0] $end
$var wire 5 R Read1 [4:0] $end
$var wire 5 S Read2 [4:0] $end
$var wire 1 < RegWrite $end
$var wire 32 T WriteData [31:0] $end
$var wire 1 ! clock $end
$var wire 32 U Data2 [31:0] $end
$var wire 32 V Data1 [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$scope module RISCVunicycle_tb $end
$var parameter 32 W CLK_PERIOD $end
$var reg 1 ! clock $end
$var reg 1 " rst $end
$scope module dut $end
$scope module extensorS $end
$upscope $end
$scope module modInstm $end
$upscope $end
$scope module modPC $end
$upscope $end
$scope module modalu $end
$upscope $end
$scope module modmemory $end
$upscope $end
$scope module modregfile $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
b10 W
$end
#0
$dumpvars
b0xxxxx V
b0xxxxx U
b0xxxxx T
b0 S
b0 R
b0 Q
bx P
b0 O
b0 N
b0xxxxx M
b0xxxxx L
b0 K
b0xxxxx J
b0 I
b0 H
zG
b0 F
bz E
bz D
zC
bx B
b0 A
b0 @
b0 ?
b0 >
b0 =
0<
b0xxxxx ;
b0 :
09
08
b0 7
b0 6
b0 5
b0xxxxx 4
b0 3
b0xxxxx 2
b0 1
b0 0
b0 /
b0 .
b0 -
b0xxxxx ,
b0xxxxx +
b0xxxxx *
b0xxxxx )
b0xxxxx (
bx '
bx &
b0 %
b0 $
x#
1"
0!
$end
#1000
b0 4
b0 T
b0 ;
b0 *
b0 M
b0 2
b0 ,
b0 L
b0xxxxx +
b0xxxxx J
1!
#2000
0"
#3000
b1 $
b1 I
1!
#4000
0!
